// Package models provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package models

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
)

// ComputerDto An object that describes required information about a computer.
type ComputerDto struct {
	// AssignedEmployee The abbrevation of the employee assigned to the computer. The employee abbreviation consists of 3 letters. For example Max Mustermann should be mmu.
	AssignedEmployee *string `json:"assignedEmployee,omitempty"`

	// Description Additional information about the computer.
	Description *string `json:"description,omitempty"`

	// Ip The IP V4 address of the computer within the company network.
	Ip string `json:"ip"`

	// Mac The MAC address of the computer within the company network.
	Mac string `json:"mac"`

	// Name The internal name of the computer.
	Name string `json:"name"`
}

// GetComputersResponse An list of object that describes computers used in the company.
type GetComputersResponse struct {
	// Computers A list of assigned computers.
	Computers []ComputerDto `json:"computers"`
}

// ServiceErrorResponse This schema represents the default response in case of an API call resulting in an error.
type ServiceErrorResponse struct {
	// Code The status error code.
	Code int `json:"code"`

	// Details An optional string of explanatatory details about the occured errors.
	Details *string `json:"details,omitempty"`

	// Name The name of the error.
	Name string `json:"name"`
}

// UpdateComputerRequest Data needed to update an computer
type UpdateComputerRequest struct {
	// AssignedEmployee The abbrevation of the employee assigned to the computer. The employee abbreviation consists of 3 letters. For example Max Mustermann should be mmu.
	AssignedEmployee *string `json:"assignedEmployee,omitempty"`

	// Description Additional information about the computer.
	Description *string `json:"description,omitempty"`

	// Ip The IP V4 address of the computer within the company network.
	Ip *string `json:"ip,omitempty"`

	// Mac The MAC address of the computer within the company network.
	Mac *string `json:"mac,omitempty"`
}

// CreateComputerJSONRequestBody defines body for CreateComputer for application/json ContentType.
type CreateComputerJSONRequestBody = ComputerDto

// UpdateComputerJSONRequestBody defines body for UpdateComputer for application/json ContentType.
type UpdateComputerJSONRequestBody = UpdateComputerRequest

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xYTVMbORP+K13Ke3TZzgt78Y2PQFEVshTL7iXh0J5p2wozkiL1GFyU//uWpJlhxpaL",
	"QFjCgZvtkbpb3c+Hxvci06XRihQ7MbkXLltQieHjkS5NxWSPWfuvmOeSpVZYXFhtyLIkJyYzLBwNRE4u",
	"s9L452IiDhTo6XfKGHiBDPHhlBxY+lFJSzlINdO2RL8ecKorBoSszjf8psRAmE6Se4HOybmi/FNpCr0i",
	"8r/1c14tCHA6tbSMUfUMeEFA9QZoIgDr8KDNBle9ZSGEjDEyrZx07HywPSiImawbwom2QHdYmoLgHO/g",
	"vHJMtkSlwC10VeQwJSjLKh6kxLvPpOa8EJO9gSil6nzjlSExEY6tVHOx3ujj5hEP2gkk+tc7U0i8FVya",
	"dNvOLuCffcA8t+Rc07gmFtxKXkjV/oZqBYr4VtubmCYWIiZCmuV+Km2JWTrv+cHRs7NuZVFY7kCFVEzW",
	"N80v2UyUjLYeiAapYvI1ho7nCE28bjdElPv0p8QNX9wlOaOVo6ezppCOfYVp9jQ1O6hc4FC3PSnWtBsS",
	"WGpztcRoV8dQkqkMG/9naSYm4sPoQSlGtUyMuhqxbtuC1uJqq40P1aQa+BfZpczok7XaPrOBVwvpIFYG",
	"lowl52sNTcpphlXBYOvIvnkZugAHVHBwcQYZFoV/XhUs1dwvQAXky0m3Nt8BN8fIlYs7wS/rQcyDcU42",
	"cp1RFqnZKNCmJnqEpC+T7kyBChlZ2xXUmzvk11lWeWkNid2TWdIlR+fUP8WM0IzUUP82OTI1ILmkHxU5",
	"fuJUj5ERFFEetbsKIf1sGjy928W7XTzRLtZbWPU/+S5tp/4Ap5ZITbXq5CtR4ZxKUuy145s6iBrCGm6I",
	"DLDF7GazSAfSuYpymK62hZslF76eR3OJgViSdbG2j8PxcOybpg0pNFJMxN5wPNzzhEBeBC6Mlh9HPSOY",
	"E2+f8oQ4W5ADbH2h6aOlufSA7TpEKNkTLkDqLPeFdwxQeJWIQhsy/n88jpqpmFTkvzGFzMLu0XcX0RuV",
	"+zHHSRptGF/qQHl7nNQxfOvXA/HHC5aXtLFEeWf1pcSvJxuWB1i6qizRrsREfPaFe0/KOm1lnDsvvA+t",
	"vl4PhNEuMdIjS8hhpIpuIfcy6nRls9qQ+uOLi5uwIso8OT7U+erFmtO7LayjmfRg8vG/SjVI9ib309//",
	"DdM/xLwxw/7QY13dYe0Y+nrQJ/aosaTR/ab5rXeS/pQ4pqrpHlWqa33+ClSHGT5C+sNV67ZefSyWFBXn",
	"a0rMNxw0hKzvnX6JVy/RXFe27bx7C2Fb0aAzn02pv35DYtR13AC9/VeH3hfNJ7pS+dsVPo/KBzROVy1W",
	"fpYK983HL1hG9OdUECdugZdU6mWQyNZtZ1aXwZ69caQwfxxidZTyUayn3js9uaYENhSQ70R+9yS/iPr9",
	"7ePHo7wJFfzdZOghMPalndVO331UVBGcoUzOZNZ/W9mpor8Ip/hy9CpwGr+WVb9r5zO1c/d1ETlbbAM3",
	"vqy7Pq5aJCugO+nCXyP998Y+lvtv/G8azi9/v03/3ZG86b4aff68eZf3DZLEMfUxvutusV7/GwAA//8e",
	"dA5wIhkAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
